import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const PROJECT_ROOT = path.resolve(__dirname, '..');
const AGENTS_DIR = path.join(PROJECT_ROOT, 'agents', 'plugins');
const OUTPUT_FILE = path.join(PROJECT_ROOT, 'src', 'data', 'generatedAgents.ts');

interface AgentData {
    plugin: string;
    id: string;
    name: string;
    description: string;
    shortDescription: string;
    model: string;
    path: string;
}

function getShortDescription(description: string): string {
    // Remove content after trigger phrases
    const stopPhrases = ['Use PROACTIVELY', 'Use proactively', 'Use when', 'Use IMMEDIATELY', 'Use immediately'];
    let short = description;

    for (const phrase of stopPhrases) {
        const idx = short.indexOf(phrase);
        if (idx > 0) {
            short = short.substring(0, idx).trim();
        }
    }

    // If still too long, take first sentence
    if (short.length > 120) {
        const period = short.indexOf('. ');
        if (period > 0 && period < 120) {
            short = short.substring(0, period + 1);
        } else {
            // Truncate at word boundary
            short = short.substring(0, 117).replace(/\s+\S*$/, '') + '...';
        }
    }

    return short;
}

const agents: AgentData[] = [];

console.log(`Scanning agents in: ${AGENTS_DIR}`);

if (!fs.existsSync(AGENTS_DIR)) {
    console.error(`Agents directory not found: ${AGENTS_DIR}`);
    process.exit(1);
}

const plugins = fs.readdirSync(AGENTS_DIR).filter(p => fs.statSync(path.join(AGENTS_DIR, p)).isDirectory());

for (const plugin of plugins) {
    const agentDir = path.join(AGENTS_DIR, plugin, 'agents');
    if (fs.existsSync(agentDir)) {
        const agentFiles = fs.readdirSync(agentDir).filter(f => f.endsWith('.md'));

        for (const file of agentFiles) {
            const content = fs.readFileSync(path.join(agentDir, file), 'utf-8');

            // Simple metadata extraction
            const nameMatch = content.match(/^name:\s*(.+)$/m);
            const descMatch = content.match(/^description:\s*(.+)$/m);
            const modelMatch = content.match(/^model:\s*(.+)$/m);

            if (nameMatch) {
                // Ensure forward slashes for the generated path property
                const relativePath = path.join('agents', 'plugins', plugin, 'agents', file).replace(/\\/g, '/');

                const description = descMatch ? descMatch[1].trim() : '';
                agents.push({
                    plugin: plugin,
                    id: file.replace('.md', ''),
                    name: nameMatch[1].trim(),
                    description: description,
                    shortDescription: getShortDescription(description),
                    model: modelMatch ? modelMatch[1].trim() : 'inherit',
                    path: relativePath
                });
            }
        }
    }
}

const fileContent = `// Auto-generated by scripts/generate-agents-index.ts
// Do not edit manually

export interface Agent {
    plugin: string;
    id: string;
    name: string;
    description: string;
    shortDescription: string;
    model: string;
    path: string;
}

export const GENERATED_AGENTS: Agent[] = ${JSON.stringify(agents, null, 4)};
`;

fs.mkdirSync(path.dirname(OUTPUT_FILE), { recursive: true });
fs.writeFileSync(OUTPUT_FILE, fileContent);
console.log(`Generated index for ${agents.length} agents at ${OUTPUT_FILE}`);
