import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const PROJECT_ROOT = path.resolve(__dirname, '..');
const AGENTS_DIR = path.join(PROJECT_ROOT, 'agents', 'plugins');
const OUTPUT_FILE = path.join(PROJECT_ROOT, 'src', 'data', 'generatedAgents.ts');

interface AgentData {
    plugin: string;
    id: string;
    name: string;
    description: string;
    shortDescription: string;
    model: string;
    path: string;
    isArchived?: boolean;
}

function getShortDescription(description: string): string {
    // Remove content after trigger phrases
    const stopPhrases = ['Use PROACTIVELY', 'Use proactively', 'Use when', 'Use IMMEDIATELY', 'Use immediately'];
    let short = description;

    for (const phrase of stopPhrases) {
        const idx = short.indexOf(phrase);
        if (idx > 0) {
            short = short.substring(0, idx).trim();
        }
    }

    // If still too long, take first sentence
    if (short.length > 120) {
        const period = short.indexOf('. ');
        if (period > 0 && period < 120) {
            short = short.substring(0, period + 1);
        } else {
            // Truncate at word boundary
            short = short.substring(0, 117).replace(/\s+\S*$/, '') + '...';
        }
    }

    return short;
}

const agents: AgentData[] = [];

function scanAgents(baseDir: string, isArchived: boolean) {
    console.log(`Scanning agents in: ${baseDir} (Archived: ${isArchived})`);

    if (!fs.existsSync(baseDir)) {
        if (!isArchived) {
            console.error(`Agents directory not found: ${baseDir}`);
            process.exit(1);
        }
        return;
    }

    const plugins = fs.readdirSync(baseDir).filter(p => fs.statSync(path.join(baseDir, p)).isDirectory());

    for (const plugin of plugins) {
        const agentDir = path.join(baseDir, plugin, 'agents');
        if (fs.existsSync(agentDir)) {
            const agentFiles = fs.readdirSync(agentDir).filter(f => f.endsWith('.md'));

            for (const file of agentFiles) {
                const content = fs.readFileSync(path.join(agentDir, file), 'utf-8');

                // Simple metadata extraction
                const nameMatch = content.match(/^name:\s*(.+)$/m);
                const descMatch = content.match(/^description:\s*(.+)$/m);
                const modelMatch = content.match(/^model:\s*(.+)$/m);

                if (nameMatch) {
                    // Ensure forward slashes for the generated path property
                    // For archived items, we still want to keep the relative path logic or adjust if needed.
                    // The path is used for ID/deletion, so sticking to standard structure is best.
                    const relativePath = path.join('agents', 'plugins', plugin, 'agents', file).replace(/\\/g, '/');

                    const description = descMatch ? descMatch[1].trim() : '';
                    agents.push({
                        plugin: plugin,
                        id: file.replace('.md', ''),
                        name: nameMatch[1].trim(),
                        description: description,
                        shortDescription: getShortDescription(description),
                        model: modelMatch ? modelMatch[1].trim() : 'inherit',
                        path: relativePath,
                        isArchived: isArchived
                    });
                }
            }
        }
    }
}

scanAgents(AGENTS_DIR, false);
const ARCHIVE_AGENTS_DIR = path.join(PROJECT_ROOT, 'ARCHIVE', 'agents', 'plugins');
scanAgents(ARCHIVE_AGENTS_DIR, true);

const fileContent = `// Auto-generated by scripts/generate-agents-index.ts
// Do not edit manually

export interface Agent {
    plugin: string;
    id: string;
    name: string;
    description: string;
    shortDescription: string;
    model: string;
    path: string;
    isArchived?: boolean;
}

export const GENERATED_AGENTS: Agent[] = ${JSON.stringify(agents, null, 4)};
`;

fs.mkdirSync(path.dirname(OUTPUT_FILE), { recursive: true });
fs.writeFileSync(OUTPUT_FILE, fileContent);
console.log(`Generated index for ${agents.length} agents at ${OUTPUT_FILE}`);
